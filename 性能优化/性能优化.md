### **一、网络请求优化**

1. **缩短资源加载时间**
   
   - **资源压缩与合并**：使用工具（如Webpack、Vite）压缩HTML、CSS、JS，合并小文件以减少HTTP请求次数。
   
   - **按需加载**：通过代码分割（Code Splitting）和动态导入（如`import()`）按需加载非首屏资源，例如路由级懒加载。
   
   - **启用Gzip压缩**：服务器端配置Gzip压缩文本资源（JS/CSS/HTML），减少传输体积（压缩率可达60%~70%）。
   
   - **升级HTTP协议**：使用HTTP/2多路复用、头部压缩等特性，或HTTP/3（基于UDP）进一步降低延迟。

2. **缓存策略优化**
   
   - **强缓存与协商缓存**：通过`Cache-Control`（优先级最高）和`ETag`控制资源缓存，减少重复请求。
   
   - **Service Worker缓存**：利用Workbox等工具预缓存静态资源，支持离线访问和二次加载加速。

3. **CDN加速与资源分发**
   
   - 将静态资源部署到CDN，利用边缘节点就近分发，降低TTFB（Time to First Byte）。
   
   - 使用独立域名存放静态资源，避免携带Cookie等冗余信息。

---

### **二、渲染流程优化**

1. **关键渲染路径优化**
   
   - **CSS置顶、JS置底**：CSS放在`<head>`中尽早构建CSSOM，JS放在`<body>`末尾或使用`async/defer`避免阻塞DOM解析。
   
   - **内联关键CSS/JS**：首屏关键代码内联到HTML，减少渲染阻塞。

2. **减少重排（Reflow）与重绘（Repaint）**
   
   - 合并DOM操作，使用`documentFragment`或框架的虚拟DOM（如React/Vue）批量更新。
   
   - 使用CSS动画替代JS动画，利用`transform`和`opacity`触发GPU加速。

3. **首屏加载优化**
   
   - **骨架屏与占位符**：在数据加载前展示骨架结构，提升用户体验5。
   
   - **服务端渲染（SSR）**：首屏由服务器直接输出HTML，减少客户端渲染时间，改善SEO。

---

### **三、代码与资源优化**

1. **JavaScript性能优化**
   
   - **避免长任务**：拆分耗时任务（如大数据计算）至Web Worker，避免阻塞主线程。
   
   - **缓存计算结果**：使用`useMemo`（React）或缓存函数结果，减少重复计算。
   
   - **Tree Shaking与按需引入**：移除未使用代码，如仅导入Lodash中的特定函数。

2. **图片与多媒体优化**
   
   - **格式选择**：使用WebP（兼容性要求低时）、SVG（矢量图）或Base64（小图标），JPEG/PNG按场景选择。
   
   - **懒加载与响应式图片**：通过`loading="lazy"`或Intersection Observer延迟加载非视口图片，结合`srcset`适配不同分辨率。

3. **构建工具优化**
   
   - **打包分析**：使用`webpack-bundle-analyzer`分析依赖体积，优化大模块。
   
   - **DLLPlugin与持久化缓存**：分离第三方库，减少重复构建。

---

### **四、其他高级策略**

1. **预加载与预解析**
   
   - `preload`关键资源（如字体、首屏图片），`dns-prefetch`预解析域名。
   
   - 使用`preconnect`提前建立TCP连接，减少握手时间。

2. **性能监控与分析**
   
   - **LCP与FID指标**：通过Web Vitals监控最大内容渲染时间（LCP < 2.5s）和首次输入延迟（FID < 100ms）。
   
   - **Chrome DevTools**：使用Performance面板分析长任务、渲染阻塞及内存泄漏。

---

### **五、综合建议**

- **优先级原则**：优先处理影响首屏的核心资源（如关键CSS/JS、首屏图片），再优化非关键路径。

- **平衡成本与效果**：如SSR需权衡服务器成本，HTTP/3需考虑浏览器兼容性。

- **持续迭代**：通过工具（如Lighthouse）定期评估性能，结合A/B测试验证优化效果。

---

# 具体怎么做？

### 场景一：使用工具（如Webpack、Vite）压缩HTML、CSS、JS，合并小文件以减少HTTP请求次数。

### **一、Webpack 实现案例（2025年最新配置）**

#### **1. 压缩HTML/CSS/JS**

**适用场景**：中大型项目，需精细控制构建流程（如多入口、旧浏览器兼容）

```js
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    minimizer: [
      new TerserPlugin({ // 压缩JS（Webpack 5默认集成）
        parallel: true, // 启用多线程压缩
        terserOptions: { compress: { drop_console: true } } // 删除console语句
      }),
      new CssMinimizerPlugin(), // 压缩CSS
    ],
    splitChunks: { // 代码分割
      chunks: 'all',
      minSize: 30000, // 合并小于30KB的文件 :cite[3]
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10, // 优先级
          filename: 'vendors.[contenthash].js'
        }
      }
    }
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      minify: { collapseWhitespace: true, removeComments: true } // 压缩HTML
    }),
    new MiniCssExtractPlugin({ filename: 'styles.[contenthash].css' }) // 提取CSS
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'] // 处理CSS
      }
    ]
  }
};
```

#### **2. 合并小文件**

**适用场景**：减少多个小模块（如工具函数、第三方库）的请求次数。

```js
// 通过 entry 或 splitChunks 合并
entry: {
  main: './src/index.js',
  vendor: ['lodash', 'axios'] // 合并第三方库
},
// 或通过 splitChunks 自动合并公共模块
```

**优化效果**：

- **压缩**：JS/CSS体积减少30%~70%（如100KB→40KB）。

- **合并**：将10个2KB的小文件合并为1个15KB文件，减少9次HTTP请求

### **二、Vite 实现案例（2025年最新配置）**

#### **1. 压缩HTML/CSS/JS**

**适用场景**：现代轻量级项目（如Vue/React单页应用），开发体验优先

```js
// vite.config.js
import { defineConfig } from 'vite';
import { createHtmlPlugin } from 'vite-plugin-html';

export default defineConfig({
  build: {
    minify: 'terser', // 使用Terser压缩JS
    cssMinify: true, // 压缩CSS
    terserOptions: {
      compress: { drop_console: true } // 删除console语句
    },
    rollupOptions: {
      output: {
        manualChunks: { // 手动合并模块
          vendor: ['lodash', 'axios'] // 合并第三方库
        }
      }
    }
  },
  plugins: [
    createHtmlPlugin({ minify: true }) // 压缩HTML
  ]
});
```

**优化效果**：

- **压缩**：JS/CSS体积减少与Webpack相近，WebP图片压缩效率更高。

- **合并**：自动Tree Shaking，默认按需分割代码，减少冗余

### **三、工具对比与适用场景**

| 工具      | 适用场景                        | 核心优势                               |
| ------- | --------------------------- | ---------------------------------- |
| Webpack | 复杂项目（多入口、旧浏览器支持、高度定制）       | 插件生态丰富（如DLLPlugin、Bundle Analyzer） |
| Vite    | 现代SPA项目（Vue/React、ESM浏览器支持） | 开发热更新快，默认优化完善（如预构建依赖）              |

----

### 场景二：通过代码分割（Code Splitting）和动态导入（如`import()`）按需加载非首屏资源,，在vue3+vite或者react+vite项目中，分别如何实现？

### 一、Vue3 + Vite 实现方案（版本：Vite 5.x + Vue3 3.4+）

#### 1. **动态导入单个组件**

通过 `defineAsyncComponent` 定义异步组件，结合 `<Suspense>` 实现按需加载。

```html
//vue文件
<template>
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent(() =>
  import('./components/HeavyComponent.vue')
);
</script>
```

**优化效果**：首屏加载时不会加载 `HeavyComponent`，直到组件被渲染时才异步加载

#### 2. **批量注册全局异步组件**

使用 `import.meta.glob` 动态导入所有组件并全局注册，适用于需要按需加载多个组件的场景。

```js
// src/plugins/async-components.js
const modules = import.meta.glob('@/components/**/*.vue')

/*
import.meta.glob 是 Vite 提供的一个特有 API，用于 基于文件系统的模块批量动态导入
。它通过通配符（Glob 模式）匹配文件路径，自动生成按需加载的模块映射，特别适合需要批量
导入组件或模块的场景（如全局注册组件、按需加载路由等）。
const modules = import.meta.glob(globPattern, options);
globPattern    string    通配符路径（如 './src/components/*.vue'）
options    object    可选配置项（如 eager: true）
*/

export default {
  install(app) {
    for (const path in modules) {
      const componentName = path.match(/\/([^\/]+)\.vue$/)[1];
      app.component(componentName, defineAsyncComponent(modules[path]));
    }
  }
};

// main.js
import { createApp } from 'vue';
import App from './App.vue';
import asyncComponents from '@/plugins/async-components';

const app = createApp(App);
app.use(asyncComponents);
app.mount('#app');
```

**适用场景**：多语言项目或组件库，按需加载不同模块的组件

#### 3. **路由懒加载**

在 Vue Router 中结合动态导入实现路由级代码分割。

```js
// router.js
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  {
    path: '/dashboard',
    component: () => import('@/views/Dashboard.vue') // 动态导入
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;
```

**优化效果**：路由访问时加载对应模块，减少首屏资源体积

### 二、React + Vite 实现方案（版本：Vite 5.x + React 18+）

#### 1. **使用 `React.lazy` 和 `Suspense`**

通过 `React.lazy` 动态导入组件，`Suspense` 提供加载状态反馈。

```jsx
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./components/HeavyComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

**注意事项**：仅支持默认导出的组件，需确保目标组件使用 `export default`

#### 2. **路由级代码分割**

结合 `React Router` 实现按需加载路由组件。

```jsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import React, { lazy, Suspense } from 'react';

const Home = lazy(() => import('./views/Home'));
const About = lazy(() => import('./views/About'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

**优化效果**：路由切换时动态加载对应模块，减少首屏加载时间 30%~50%

#### 3. **动态导入第三方库**

按需加载大型第三方库（如 `lodash`），减少初始包体积。

```js
// 点击按钮时加载 lodash 的 debounce 方法
const handleClick = async () => {
  const { debounce } = await import('lodash-es');
  debounce(() => console.log('Debounced!'), 1000);
};
```

**适用场景**：非首屏依赖的功能库，避免主包体积过大

### 三、通用优化策略（Vite 配置）

#### 1. **自定义分块策略**

在 `vite.config.js` 中通过 Rollup 配置手动分块：

```js
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('node_modules')) {
            return 'vendor'; // 第三方库单独分块
          }
        }
      }
    }
  }
});
```

**优化效果**：将 `node_modules` 代码单独打包，利用浏览器缓存

#### 2. **预加载关键资源**

使用 `preload` 预加载首屏必要资源：

```html
<link rel="modulepreload" href="/src/main.js" />
```

**适用场景**：提升首屏渲染速度，减少关键资源加载延迟

### 四、工具与验证

1. **分析打包体积**：
   
   - **Vite**：运行 `vite build --report` 生成分析报告。
   
   1.安装rollup-plugin-visualizer进行打包分析
   
   ```javascript
   npm i rollup-plugin-visualizer -D
   ```
   
   2.修改vite.config.ts配置文件如下：
   
   ```javascript
   //vite.config.ts
   import { visualizer } from "rollup-plugin-visualizer"
   
   const lifecycle = process.env.npm_lifecycle_event;
   export default defineConfig(({ mode }: UserConfig): UserConfig => {
    plugins: [
         // 只有在report命令下才配置打包分析插件
       lifecycle === "report"? 
           visualizer({ 
               open: true, 
               brotliSize: true, 
               filename: "report.html" 
           }): null
       ]
   }
   ```
   
   3.修改package.json文件
   
   ```javascript
   // package.json
   scripts:{
      "report": "rimraf dist && cross-env vite build",
   }
   如果打包文件不在dist，请修改dist为打包目录。如果没有cross-env请在开发环境先
   安装。
   ```
   
   4.运行report命令则可 npm run report后会自动在浏览器打开，效果如下![](https://i0.hdslb.com/bfs/article/82609c5501f569c628487f748d7df5ad3cfbdb95.png)
   
   - **React**：使用 `source-map-explorer` 分析代码占比。
   
   1:安装分析打包体积的包：npm i source-map-explorer
   2:在 package.json 中的 scripts 标签中，添加分析打包体积的命令
   3:对项目打包：npm run build（如果已经打过包，可省略这一步）
   4:运行分析命令：npm run analyze
   5:通过浏览器打开的页面，分析图表中的包体积

```json
"scripts": {
  "analyze": "source-map-explorer 'build/static/js/*.js'",
}
```

   ![](https://i-blog.csdnimg.cn/blog_migrate/0668000009a9e8354ea9db5c04a18140.png)

2. **性能监控**：
   
   - **Lighthouse**：评估加载性能，优化 LCP（最大内容渲染时间）和 FID（首次输入延迟）。
   
   - **WebPageTest**：查看资源加载瀑布图，验证分块效果

### 总结

- **Vue3 + Vite**：通过 `defineAsyncComponent`、`import.meta.glob` 和路由懒加载实现按需加载，适合组件化程度高的应用。

- **React + Vite**：使用 `React.lazy` 和路由级分割，结合 Suspense 提升用户体验，适合单页应用（SPA）。

- **通用优化**：分块策略和预加载能进一步提升性能，需结合项目场景选择方案。

---
