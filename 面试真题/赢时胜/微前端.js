//1:为什么要使用微前端呢？出于什么原因和诉求？

// 业务整合的直接需求：
// 公司内部存在多个独立的运营后台（如您看到的“云集”监控平台、“数据大脑”分析平台等），它们由不同时期、不同团队开发。运营人员需要在多个浏览器标签页间切换，体验割裂，账号体系也可能不互通。
// 我们的核心诉求就是为这些分散的后台提供一个统一的操作入口和用户体验，这正是微前端“聚合”能力的典型场景。

// 技术栈并存与平滑演进：
// 就像我简历中提到的，公司同时存在 Vue 和 React 技术栈。例如“云集”是基于 Vue3 的，而新的“数据大脑”是基于 React 的。我们不可能为了统一技术栈而将所有系统重写。
// 微前端方案允许我们在基座中无缝集成 Vue 和 React 应用，尊重了技术历史，也给了团队技术选型的自由。同时，它也为我们未来渐进式重构或升级某个子应用铺平了道路。

// 提升组织协同与发布效率：
// 在实施微前端之前，若想在一个大平台中新增一个功能模块，所有相关团队都需要在同一个巨型仓库上协作，发布流程冗长且风险集中。实施后，各个后台（子应用）团队可以完全独立地开发、
// 测试和部署自己的模块。例如，“云集”团队的迭代不会影响到“数据大脑”的稳定性，上线节奏也互不干扰，这极大提升了各团队的自治效率和整体交付速度。

// 所以，我们选择微前端，为了解决公司内部多后台整合困难、技术栈不统一、团队协作耦合度高这三个具体痛点。最终我们成功接入了多个后台并稳定运行，验证了该架构在当时我们业务场景下的必要性。





//2.有没有遇到什么问题？你是如何解决的呢？
// 问题一：父子应用路由状态不同步

// 具体现象：在子应用（如“云集”）内部进行路由跳转后，浏览器的地址栏URL有时未同步更新，或者刷新页面后，基座应用无法正确识别当前路由并激活对应的子应用，导致页面白屏或跳转错误。

// 根因分析：我们使用的 micro-app 提供了基础的路由同步能力，但在我们的复杂场景下（子应用有嵌套路由、路由守卫、且部分跳转为编程式导航），其默认行为存在边缘情况缺失。
// 问题的核心在于，子应用路由变化时，未能100%可靠地触发基座路由的更新，反之亦然，导致两者状态脱节。

// 解决方案：
// 增强通信机制：我们没有完全依赖框架的自动化同步，而是建立了一个更健壮的路由事件通信层。
// 当子应用内部发生路由跳转（无论是通过 <router-link> 还是 router.push），我们都会通过 micro-app 的通信API，手动向基座发送一个标准化的事件，携带完整的目标路由信息。
// 基座统一监听与响应：基座应用监听所有子应用发来的路由变更事件，并以此为依据，同时更新两处状态：一是更新基座自身维护的、用于激活子应用的活动路由状态；二是通过History API，谨慎地同步浏览器地址栏的URL（确保不会引发循环跳转）。
// 制定路由规范：我们为所有接入团队制定了路由命名空间规范，要求子应用的路由前缀必须唯一，从源头上减少了路由匹配冲突的可能性。这个过程体现了“技术方案与团队规范必须同步推进”的架构经验。

// 问题二：子应用卸载时的内存泄漏

// 具体现象：运营人员在多个后台间频繁切换后，页面内存占用持续攀升，最终导致浏览器标签页响应迟缓甚至崩溃。

// 根因分析：通过Chrome DevTools的Memory面板进行堆快照对比分析，我们发现泄漏主要来自三个方面：
// 未清理的全局事件监听器：子应用中某些组件绑定了 window 的 resize、scroll 等全局事件，卸载时未移除。
// 未被回收的定时器：一些轮询任务或动画的 setInterval 未被清除。
// 框架级残留：更隐蔽的是，micro-app 沙箱卸载时，某些极端情况下子应用的全局状态/样式表未彻底清除。

// 解决方案：
// 强化子应用生命周期管理：我们为每个子应用制定了严格的卸载清理清单。在子应用的 unmount 生命周期钩子中，必须：
// 清除所有自定义的全局事件监听器。
// 清除所有定时器。
// 手动销毁由第三方库（如ECharts、地图SDK）创建的实例。
// 基座侧主动清理：我们深入研究了 micro-app 的源码，在其子应用卸载的回调中，增加了额外的强制性清理步骤。例如，主动遍历并移除子应用沙箱可能残留的 <style> 标签，并确保其隔离的 window 代理被完全置空。
// 这相当于为框架的沙箱机制加了一道“保险”。
// 建立监控与Code Review机制：我们将内存泄漏检查纳入团队的Code Review清单，并编写了示例代码和常见陷阱文档。同时，在开发阶段就鼓励使用内存分析工具进行自查。

// 总结：解决这两个问题不仅让平台稳定运行，更重要的是为我们团队沉淀了两条核心经验：
// 第一，微前端框架不是“黑盒”，深入理解其原理是解决复杂问题的前提；
// 第二，架构的成功不仅依赖于技术方案，同样依赖于配套的开发规范和团队共识。 这些经验也让我后续在主导其他技术选型时，更加注重方案的可观测性、可调试性以及团队的整体适配成本。





// 3.microapp的事件通信机制是怎么样的？
// micro-app 的事件通信机制是其核心特性之一，它设计得较为简洁灵活，主要提供了两种方式：数据绑定和自定义事件。这两种方式共同构成了主子应用间、子应用相互间的通信桥梁。
// 其设计哲学是尽可能贴近原生开发体验，因此它直接基于浏览器的 CustomEvent API 和 发布-订阅 模式进行构建。

// 3.1. 数据绑定（响应式状态）
// 这种方式类似于Vue的 props 或React的 props，允许基座应用向子应用传递数据，且当数据变化时，子应用能自动接收到更新。
// 实现方式：基座通过 <micro-app> 标签的 data 属性传递一个对象。micro-app 内部会监听这个对象的变化（利用 Proxy 或 defineProperty），并将其深度复制到子应用的沙箱环境中。
// 子应用接收：子应用通过全局函数 window.microApp.getData() 获取初始数据，并通过监听 datachange 事件来响应数据变化。
// 特点：这是一种单向数据流，适合基座向子应用下发配置、用户信息、全局状态等。

// 3.2. 自定义事件
// 这是一种更通用、更灵活的双向通信方式，允许任何一方主动发送事件，并携带任意可序列化的数据。

// 发送事件：
// 基座向子应用发送：通过 <micro-app> 实例的 dispatch 方法。
// 子应用向基座或其它子应用发送：通过 window.microApp.dispatch 方法。

// 监听事件：
// 通过 window.microApp.addDataListener 方法添加监听器。
// 监听器回调函数会接收事件对象，其中包含发送方传递的数据。
// 移除监听：为了避免内存泄漏，在应用或组件卸载时，必须使用 window.microApp.removeDataListener 或 window.microApp.clearDataListener 来清理监听器。
// 特点：这是完全双向的，适用于各种交互场景，如通知、命令、状态同步等。

// 关键特性与注意事项
// 沙箱隔离下的通信：所有通信都经过 micro-app 的调度中心，确保事件能在隔离的沙箱环境中正确路由。
// 数据序列化：传递的数据必须是可序列化的（如对象、数组、字符串），避免传递函数、DOM元素等。
// 性能与维护：虽然灵活，但过度使用事件通信（尤其是全局广播）会增加系统的耦合度和复杂度。最佳实践是按需通信，并定义清晰的通信协议。





//4.有没有了解过其他的微前端框架？
// Qiankun	蚂蚁集团	基于 single-spa，提供完善的JS/CSS沙箱隔离和生命周期管理。社区成熟，是国内使用最广泛的方案之一。

// 无界 (Wujie)	腾讯	采用 WebComponent + iframe融合方案。隔离性极强，子应用可实现保活（状态保持），性能较好。





//5.iframe可以用于做微前端的实现吗？有没有哪个框架是这样做的？为什么？
// 可以，iframe本身就是最原始的“微前端”方案，并且现在确实有成熟的微前端框架（例如腾讯的 无界 (Wujie)）是以 iframe 为核心思想进行创新和增强的。

// 🧱 iframe的传统：天然隔离的“微前端”
// 在微前端概念流行前，用 iframe 整合多个独立应用是常见做法。它的核心特性与微前端需求高度相关：

// 优点：
// 天然的沙箱隔离：JS、CSS完全隔离，几乎不可能相互干扰，安全性高。
// 技术栈无关：每个 iframe 如同一个独立浏览器环境，可运行任何技术栈。
// 独立运行时：页面崩溃、内存泄漏通常被限制在 iframe 内部，不影响主应用。
// 独立部署：可单独更新和部署 iframe 内的应用。

// 缺点（传统痛点）：
// 用户体验割裂：路由、历史记录不统一；浏览器刷新可能导致白屏；弹窗只能在 iframe 框内。
// 通信复杂困难：只能通过 postMessage 进行通信，数据同步和状态管理繁琐。
// 性能开销大：每个 iframe 都是一份完整的浏览器上下文，内存和计算资源占用高。
// SEO不友好：爬虫通常难以抓取 iframe 内的内容。