# 一：浏览器渲染流程与关键路径优化

网络线程收到HTML文档，产生一个渲染任务，给到渲染主线程的消息队列。

**整个渲染流程分为多个阶段：**

1：解析HTML，构建DOM树/CSSOM树

```js
解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。
为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML中的外部
CSS文件和 外部的 JS 文件。
如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继
续解析后续的HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是CSS不
会阻塞 HTML 解析的根本原因。
如果分线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码
解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 
树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML解析的根本原因，
第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样
式均会包含在CSSOM 树。
```

2：构建渲染树

```tex
样式计算
主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed 
Style。
在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0);相对单位会变成绝
对单位，比如 em 会变成 px这一步完成后，会得到一棵带有样式的DOM 树。
```

3：构建布局树

```js
布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。
例如节点的宽高、相对包含块的位置。大部分时候，DOM 树和布局树并非一一对应，
比如 display:none 的节点没有几何信息，因此不会生成到布局树;
又比如使用了伪元素选择器，虽然 DOM树中不存在这些伪元素节点，但它们拥有几何信息，
所以会生成到布局树中。
还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。
```

4：分层

```js
分层。主线程会使用一套复杂的策略对整个布局树中进行分层。
分层的好处在于，将来某一个层改变后，仅会对该云进行后续处理，从而提升效率。 
样式都会或多或少的影响分层结果，也可以通过 will-滚动条、堆叠上下文、
transform、opacity 等change 属性更大程度的影响分层结果。
```

5：绘制

```js
主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来.
```

6：合成

```tex
主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域,它会从线程池中拿取多个线程来
完成分块工作。

分块完成后，进入光栅化阶段。合成线程会将块信息交给 GPU进程，以极高的速度完成光栅化。
GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。光栅化的结果，就是
一块一块的位图

合成线程拿到每个层、每个块的位图后，生成一个个「指引(quad)」信息。
指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。变形发生在
合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。
合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成
最终的屏幕成像。
```

总结渲染流程及优化手段：

- 构建DOM树/CSSOM树 → 渲染树 → 布局 → 分层→ 绘制 → 合成

- 优化手段：异步加载CSS、减少重排/重绘、使用`will-change`、`content-visibility`等

# **二. 现代浏览器的多进程架构 **（以Chrome为例）****

##### **1. 核心进程及作用**

Chrome的多进程架构主要包含以下进程：

- **浏览器主进程（Browser Process）**
  
  - 负责地址栏、书签、前进/后退等UI交互。
  
  - 管理其他进程的创建和销毁（如标签页、插件）。
  
  - 处理网络请求（通过网络子模块）和文件访问。

- **渲染进程（Renderer Process）**
  
  - **每个标签页独立一个渲染进程**（默认策略，可通过Site Isolation调整）。
  
  - 负责HTML/CSS/JS解析、布局、渲染（Blink和V8引擎运行在此）。
  
  - **沙箱化**：禁止直接访问系统资源（如文件、网络），需通过主进程IPC通信。

- **GPU进程（GPU Process）**
  
  - 集中处理所有标签页的GPU加速任务（CSS 3D、WebGL、合成图层）。
  
  - 独立进程可避免GPU驱动崩溃影响整个浏览器。

- **插件进程（Plugin Process）**
  
  - 隔离Flash等插件，防止插件崩溃影响页面（现逐渐被Web标准替代）。

- **网络进程（Network Process）**
  
  - Chrome 65+将网络模块独立为进程，管理请求、缓存、Cookie等。

- **工具进程（Utility Processes）**
  
  - 运行一些辅助功能（如音视频解码、文件解析）。

---

##### **2. 多进程设计的优缺点**

**优势**：

- **稳定性**：单个标签页崩溃不会影响其他标签页（渲染进程隔离）。

- **安全性**：沙箱机制限制渲染进程权限，防止恶意代码攻击系统。

- **性能**：多进程充分利用多核CPU（如并行解析多个页面的JS）。

**缺点**：

- **资源占用高**：每个进程独立内存空间（如多个标签页需重复加载V8引擎）。

- **进程间通信（IPC）开销**：渲染进程需通过主进程访问网络/文件，可能引入延迟。

> **优化方向**：Chrome通过**进程共享**（如同一站点的多个标签共享渲染进程）和**进程合并**（如Android上减少进程数）平衡性能与资源。

# 三. 事件循环（Event Loop）

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列未尾即可。
过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。
不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

单线程是异步产生的原因，事件循环是异步的实现方式

# **四. 跨域解决方案与安全限制**

### **1. 同源策略（Same-Origin Policy, SOP）**

**定义**

- 同源策略是浏览器的核心安全机制，限制**不同源**的文档或脚本交互。

- **同源条件**：协议（`http/https`）、域名（`example.com`）、端口（`80/443`）**完全相同**。

**为什么需要限制跨域？**

- **防止CSRF（跨站请求伪造）**：恶意网站不能直接读取用户在其他网站的Cookie。

- **防止XSS（跨站脚本攻击）**：阻止恶意脚本窃取敏感数据（如`localStorage`）。

- **保护用户隐私**：限制不同网站间的数据泄露（如`iframe`嵌套银行页面）。

> **例外**：某些标签（如`<img>`、`<script>`、`<link>`）允许跨域加载资源，但JS无法直接读取内容（除非使用CORS）。

---

### **2. 常见跨域解决方案**

 **（1）JSONP（JSON with Padding）**

**原理**：利用`<script>`标签不受同源策略限制的特性，动态插入脚本获取数据。

**优点**：兼容老式浏览器（IE8）。  
**缺点**：

- **仅支持GET请求**，无法POST。

- **不安全**：可能遭受XSS攻击（需信任返回的数据）。

 **（2）CORS（Cross-Origin Resource Sharing）**

**原理**：服务器设置`Access-Control-Allow-Origin`响应头，允许指定源的跨域请求。  
**简单请求（Simple Request）**：

- 方法：`GET`、`POST`、`HEAD`

- 头部：`Content-Type`仅限`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`

- 浏览器直接发送请求，检查响应头是否允许跨域。

**预检请求（Preflight Request）**：

- 非简单请求（如`PUT`、`DELETE`、自定义头`X-API-Key`）会先发送`OPTIONS`请求。

- 服务器需返回：
  
  ```http
  Access-Control-Allow-Origin: https://your-site.com
  Access-Control-Allow-Methods: GET, POST, PUT
  Access-Control-Allow-Headers: X-API-Key
  ```

**优点**：支持所有HTTP方法，安全性高（需服务器显式允许）。  
**缺点**：

- 复杂请求会增加一次`OPTIONS`请求（影响性能）。

- 旧版IE（<=9）不支持。

**（3）代理服务器（Proxy）**

**原理**：前端请求同域名的代理服务器，由代理服务器转发请求到目标API。

**优点**：

- 完全绕过浏览器限制，适用于任何跨域场景。

- 可缓存、负载均衡。  
  **缺点**：需额外服务器资源，可能成为性能瓶颈。

**（4）`postMessage`（跨文档通信）**

**原理**：通过`window.postMessage`在不同窗口/`iframe`间安全传递数据。

```js
// 父窗口（https://parent.com）
iframe.contentWindow.postMessage('Hello', 'https://child.com');
// iframe窗口（https://child.com）
window.addEventListener('message', (e) => {
  if (e.origin !== 'https://parent.com') return; // 验证来源
  console.log(e.data); // "Hello"
});
```

**优点**：安全可控，支持任意数据格式。  
**缺点**：仅适用于窗口间通信，不适合API请求。

**（5）WebSocket**

**原理**：WebSocket协议不受同源策略限制（但服务器可验证`Origin`头）。

```js
const socket = new WebSocket('wss://api.example.com');
socket.onmessage = (e) => console.log(e.data);
```

**优点**：全双工通信，适合实时应用（如聊天室）。  
**缺点**：需服务器支持WebSocket协议。

---

## **3. CORS优化方案**

1. **减少预检请求**：
   
   - 尽量使用简单请求（如`GET` + 标准`Content-Type`）。
   
   - 合并自定义头，减少`OPTIONS`请求次数。

2. **缓存预检响应**：
   
   - 服务器设置`Access-Control-Max-Age: 86400`（缓存1天）。

3. **CDN加速CORS**：
   
   - 在CDN边缘节点缓存`Access-Control-Allow-Origin`头。

---

## **4. 安全防御措施**

1. **严格限制`Access-Control-Allow-Origin`**：
   
   - 避免使用`*`（允许所有域），应动态返回请求的`Origin`（白名单）。

2. **验证`Origin`头**：防止伪造请求（如`POST` + `Origin: https://attacker.com`）。

3. **CSRF Token**：即使跨域请求成功，仍需验证Token防止恶意提交。

4. **`SameSite` Cookie**：设置`SameSite=Lax|Strict`，防止跨域携带敏感Cookie。



# **五. 浏览器存储方案与选型**

### **1. 常见浏览器存储方案对比**

| 存储方案               | 容量      | 生命周期             | 访问方式 | 适用场景            |
| ------------------ | ------- | ---------------- | ---- | --------------- |
| **Cookie**         | ~4KB    | 可设置过期时间          | 同步   | 会话管理、CSRF Token |
| **LocalStorage**   | ~5-10MB | 持久化（手动清除）        | 同步   | 长期存储（如用户偏好设置）   |
| **SessionStorage** | ~5-10MB | 标签页关闭后失效         | 同步   | 临时数据（如表单草稿）     |
| **IndexedDB**      | ≥50%磁盘  | 持久化（手动清除）        | 异步   | 结构化大数据（如离线数据库）  |
| **Cache API**      | 动态限制    | 依赖Service Worker | 异步   | 静态资源缓存（PWA离线支持） |
| **Web SQL**        | ~5-50MB | 持久化（已废弃）         | 异步   | 旧版SQL兼容（不推荐新项目） |

### **2. 各存储方案详解**

**（1）Cookie**

**特点**：

- 自动随HTTP请求发送（`Set-Cookie` / `Cookie`头）。

- 可设置`HttpOnly`（防XSS）、`Secure`（仅HTTPS）、`SameSite`（防CSRF）。

```js
// 设置Cookie（默认会话级）
document.cookie = "username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";
// 读取Cookie  
console.log(document.cookie); // "username=John; theme=dark"
```

**缺点**：

- 容量极小（4KB），频繁请求会增加Header大小。

- 同步API，可能阻塞主线程。

**（2）LocalStorage & SessionStorage**

**特点**：

- 键值存储，仅限字符串（需`JSON.stringify`处理对象）。

- **LocalStorage**：跨会话持久化，同源共享。

- **SessionStorage**：仅当前标签页有效，刷新后保留。

**缺点**：

- 同步API，大数据可能卡顿。

- 无索引，查询效率低。

**（3）IndexedDB**

**特点**：

- 异步、事务型NoSQL数据库，支持索引、游标。

- 适合存储大量结构化数据（如用户日志、离线应用数据）。

```js
// 打开数据库
const request = indexedDB.open('MyDB', 1);

request.onupgradeneeded = (e) => {
  const db = e.target.result;
  db.createObjectStore('users', { keyPath: 'id' });
};

request.onsuccess = (e) => {
  const db = e.target.result;
  const tx = db.transaction('users', 'readwrite');
  const store = tx.objectStore('users');
  store.add({ id: 1, name: 'Alice' });
};
```

**优点**：

- 支持复杂查询（比LocalStorage高效）。

- 可存储Blob、ArrayBuffer等二进制数据。

**缺点**：

- API复杂（推荐使用封装库如`idb`、`Dexie.js`）。

**（4）Cache API（Service Worker）**

**特点**：

- 用于缓存网络请求（HTML/CSS/JS/图片等）。

- 配合Service Worker实现离线优先策略。

```js
// Service Worker中缓存资源
self.addEventListener('fetch', (e) => {
  e.respondWith(
    caches.match(e.request).then((response) => {
      return response || fetch(e.request);
    })
  );
});
```

**缓存策略**：

- **Cache First**：优先返回缓存，适合静态资源。

- **Network First**：优先请求网络，失败后回退缓存（适合动态数据）。

---

### **总结**

- **小数据+简单读写** → LocalStorage / SessionStorage

- **结构化大数据** → IndexedDB

- **网络请求缓存** → Cache API + Service Worker

- **会话管理** → Cookie（配合`SameSite`/`HttpOnly`）

通过合理组合不同存储方案，可平衡性能、安全性与用户体验。



# **六. 内存泄漏分析与排查**

**问题**：哪些操作会导致浏览器内存泄漏？如何用Chrome DevTools定位泄漏点？  
**考察点**：

- 全局变量、未清除的定时器、闭包、Detached DOM

- Memory面板的Heap Snapshot和Allocation Timeline

# **七. 性能监控与指标量化**

**问题**：如何测量并优化LCP（Largest Contentful Paint）和CLS（Cumulative Layout Shift）？  
**考察点**：

- Web Vitals指标、`PerformanceObserver` API

- 图片懒加载、字体FOUT/FOIT优化

# **八. 浏览器新特性与API实践**

**问题**：举例说明Web Components、WebAssembly或Web Workers在实际项目中的应用场景及限制。  
**考察点**：

- Shadow DOM的样式隔离、Worker的通信开销

- WASM的高性能计算适用场景

# 九. 渲染引擎差异与兼容性处理

**问题**：如何解决Safari与其他浏览器在Flexbox/Grid布局或CSS特性支持上的差异？  
**考察点**：

- 特性检测（`@supports`）、Autoprefixer工具

- 渐进增强（Progressive Enhancement）策略






